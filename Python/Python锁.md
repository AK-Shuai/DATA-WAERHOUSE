# python锁

## GIL锁

### 全局解释器锁(GIL)
无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行。

### 为什么GIL锁要加在python解释器这一层，而却不加在其他地方？
全局解释器锁，也是 Python 默认解释器 CPython 自带，因为你python调用的所有线程都是原生线程。原生线程是通过C语言提供原生接口，相当于C语言的一个函数。你一调它，你就控制不了了它了，就必须等它给你返回结果。只要已通过python虚拟机，再往下就不受python控制了，就是C语言自己控制了。你加在python虚拟机以下，你是加不上去的。同一时间，只有一个线程穿过这个锁去真正执行。其他的线程，只能在python虚拟机这边等待。

**扩展 Python 其他解释器**：
- CPython：C语言开发，使用最广，默认的解释器
- IPython：基于CPython之上的交互式解释器
- PyPy：采用JIT技术，对python代码进行动态编译，追求执行速度
- Jython：运行在Java平台上的解释器，可以直接编译成Java字节码执行
- IronPython：同理Jython，运行在 .Net 平台上

## 线程锁
互斥锁：lock（一次只能放行一个）
递归锁：rlock（一次只能放行一个）
条件锁：condition（一次可以放行任意个）
事件锁：event（一次全部放行）
信号量锁：semaphore（一次可以放行特定个）

### 互斥锁

1. 用theading.Lock()创建一个lock的实例。
2. 在线程启动之前通过lock.acquire()加加锁，在线程结束之后通过lock.release()释放锁。
3. 这层锁是用户开的锁，就是我们用户程序的锁。跟我们这个GIL没有关系，但是它把这个数据相当于copy了两份，所以在这里加锁，以确保同一时间只有一个线程，真真正正的修改这个数据，所以这里的锁跟GIL没有关系，你理解就是自己的锁。
4. 加锁，说明此时我来去修改这个数据，其他人都不能动。然后修改完了，要把这把锁释放。这样的话就把程序编程串行了。

### 递归锁
互斥锁升级版，只要一个线程拿到一个锁了，其他线程必须等待拿到线程释放全部锁，才能接着拿锁。